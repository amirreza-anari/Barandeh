package ir.amirrezaanari.barandehplanning.planning.database

import android.content.Context
import androidx.room.Dao
import androidx.room.Database
import androidx.room.Delete
import androidx.room.Entity
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.PrimaryKey
import androidx.room.Query
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

/**
 * Represents a date entry in the local database.
 *
 * This entity stores a date as a string and the timestamp when the entry was created.
 * It's designed for use with Room Persistence Library for local data storage.
 *
 * @property date The date represented as a string. This is the primary key for the entity.
 *               The format of the string is not enforced by the entity itself but should be consistent
 *               within the application (e.g., "yyyy-MM-dd" or "MM/dd/yyyy").
 * @property createdAt The timestamp (in milliseconds since the epoch) indicating when this date entry was created.
 *                     Defaults to the current system time when a new `DateEntity` is instantiated.
 */// Data Entities
@Entity(tableName = "dates")
data class DateEntity(
    @PrimaryKey val date: String,
    val createdAt: Long = System.currentTimeMillis()
)

/**
 * Represents a task entity stored in the local database.
 *
 * This data class defines the schema for the "tasks" table,
 * storing information about individual tasks, including their
 * scheduling, details, and visual representation.
 *
 * @property id The unique identifier for the task. Auto-generated by the database.
 * @property date The date on which the task is scheduled (e.g., "2023-10-27").
 * @property title The title or short description of the task.
 * @property startTime The start time of the task (e.g., "09:00").
 * @property endTime The end time of the task (e.g., "10:30").
 * @property details More detailed information about the task.
 * @property color An integer representing the color associated with the task.
 *                  This can be used for visual differentiation in the UI.
 * @property isPlanned A boolean flag indicating whether the task is planned or not.
 *                     This can be used for filtering or different display modes.
 */
@Entity(tableName = "tasks")
data class TaskEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val date: String,
    val title: String,
    val startTime: String,
    val endTime: String,
    val details: String,
    val color: Int,
    val isPlanned: Boolean
)

// Data Access Objects (DAO)
@Dao
interface DateDao {
    @Query("SELECT * FROM dates ORDER BY date DESC")
    fun getAllDates(): Flow<List<DateEntity>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertDate(date: DateEntity)

    @Delete
    suspend fun deleteDate(date: DateEntity)
}

@Dao
interface TaskDao {
    @Query("SELECT * FROM tasks WHERE date = :date AND isPlanned = 1")
    fun getPlannedTasksForDate(date: String): Flow<List<TaskEntity>>

    @Query("SELECT * FROM tasks WHERE date = :date AND isPlanned = 0")
    fun getCompletedTasksForDate(date: String): Flow<List<TaskEntity>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertTask(task: TaskEntity)

    @Update
    suspend fun updateTask(task: TaskEntity)

    @Delete
    suspend fun deleteTask(task: TaskEntity)

    @Query("SELECT COUNT(*) FROM tasks WHERE isPlanned = 1")
    fun getTotalPlannedTasks(): Flow<Int>

    @Query("SELECT COUNT(*) FROM tasks WHERE isPlanned = 0")
    fun getTotalCompletedTasks(): Flow<Int>
}

// Database
@Database(entities = [DateEntity::class, TaskEntity::class], version = 1)
abstract class PlannerDatabase : RoomDatabase() {
    abstract fun dateDao(): DateDao
    abstract fun taskDao(): TaskDao

    companion object {
        @Volatile
        private var INSTANCE: PlannerDatabase? = null

        fun getInstance(context: Context): PlannerDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    PlannerDatabase::class.java,
                    "planner_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}

// Repository
class PlannerRepository(private val dateDao: DateDao, private val taskDao: TaskDao) {
    // Date operations
    fun getAllDates() = dateDao.getAllDates()

    suspend fun insertDate(date: DateEntity) {
        dateDao.insertDate(date)
    }

    // Task operations
    fun getPlannedTasksForDate(date: String) = taskDao.getPlannedTasksForDate(date)

    fun getCompletedTasksForDate(date: String) = taskDao.getCompletedTasksForDate(date)

    suspend fun insertTask(task: TaskEntity) {
        taskDao.insertTask(task)
    }

    suspend fun updateTask(task: TaskEntity) {
        taskDao.updateTask(task)
    }

    suspend fun deleteTask(task: TaskEntity) {
        taskDao.deleteTask(task)
    }

    fun getTotalPlannedTasks() = taskDao.getTotalPlannedTasks()

    fun getTotalCompletedTasks() = taskDao.getTotalCompletedTasks()
}